https://github.com/ArtemGr/Sidekick/issues/221

( https://discordapp.com/channels/@me/210056925897949184/656101297719738384 )

☒ Verify that Sidekick can send a message to any user with a known ID or nick#hash  
  ⇒ I've [added a Create DM implementation](https://github.com/ArtemGr/discord-rs/commit/388db7b903d2ef1b765d0eb41013f75b25a12503) that allows us to create or obtain a private channel to user. There is now an experimental forwarding in `fn mobile`. It works with Art, but should probably test it with users who didn't communicate with Sidekick yet.  
  ⇒ So with Mateus `create_dm` worked NP but `send_message` failed with `Forbidden`. Looks like it's not enough to have a person in a friend list, one still have to [share a server with the bot](https://stackoverflow.com/questions/49358108/in-discord-js-can-i-send-directmessage-to-user-with-discordbot). After Mateus joining such a server the message came through NP.
☐ Parse `/r share "pair programming" with 126848363613126656`  
☐ Parse `/r share "pair programming"`  
☐ Handle the `with` case  
☐ Generate a message and try to send it  
☐ If sending fails with `Forbidden` then share an invite link with the originating user  
☐ Detect when the targeted user becomes available (Discord ought to send a new user event)  
→ ☐ Track the identifiers of the users known to the bot?  
☐ Continue the process when the user becomes available, re-generate and re-send the message  
☐ Alternatively - just keep trying to send the message for a while  
…  

☐ Forward the private messages sent to the bot to _?
☐ Forward the replies, identified by _, back to the user?

☑ See if we're getting the status update events ⇒ Now we do  
☑ Handle `/r track time`  
☑ Reply with instructions (asking user to update the status)  
☐ Catch status updates in the shards, updating a separate status table, skipping duplicated events  
☐ Also catch when the user becomes idle, updating the same table  
☐ Run a maintenance loop in the handler  
☐ Use the SQLite callback to gather the IDs of recent status updates in order to process them faster  
☐ If the handler is a secondary one, then use the SQLite callback to monitor when the changes to the tracking table last happened; if the secondary handler don't observe any changes in the tracking table for N minutes then it performs its own maintenance run  
☐ Gather a list of entries to maintain: status updates ∪ *active* entries which hasn't been maintanied for N seconds  
☐ In a replicated session go over them and: update the status and the time it was discovered; update the last maintenance time; update the time histogram (86400 / 60 / 10 / 8 = 18 bytes/day; or RLE); if the status is too old, turn the entry off  
☐ Go over the entries again, outside of a replicated session, and edit the reply messages, updating the time tracked and time remaining for a scheduled status update  
  If the status time is expired then we delete the reply message and recreate it, in order to trigger notification  
